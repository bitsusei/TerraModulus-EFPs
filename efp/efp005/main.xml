<?xml version="1.1" encoding="UTF-8" ?>
<efp xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../efp.xsd"
     efp="5" created="2025-05-17" category="process" status="draft" title="Ferricia Engine Architecture">
	<metadata>
		<pullRequests>
			<pullRequest id="8"/>
			<pullRequest id="9"/>
		</pullRequests>
	</metadata>
	<body>
		<section title="Introduction">
			<content>
				<p>
					The <b>Ferricia Engine</b> (later referred as "the Engine") is the core component of TerraModulus,
					consisting of several functionalities, built with low level language <i>Rust</i>.
					Rust is a powerful language that provides good memory-safe features with excellent performance,
					favoring computational heavy tasks.
					This includes rendering, world generation, networking, physics and raw resource management.
				</p>
			</content>
		</section>
		<section title="Platform">
			<content>
				<p>
					Since the Rust library would be directly compiled into native dynamic libraries to be used by
					the Kotlin layer through Java Virtual Machine (JVM), the code must be supported by the targetted
					platforms. Therefore, platform support would typically be aligned with
					Java Runtime Environment (JRE) binary; when all modern supported platform versions of Windows,
					macOS and Linux are targetted, the list of variations that should at least fully be supported is:
				</p>
				<list>
					<li>Linux 5+ x64/arm64</li>
					<li>macOS 10.15+ x64/arm64</li>
					<li>Windows 10+ x64/x86/arm64</li>
				</list>
				<p>
					Although 32-bit platforms have become rare on personal computers, it is still possible on some
					Windows laptops, so it may still be supported with some special treatment. The engine would be
					fully written in Rust, including Foreign Function Interface (FFI) components, but as a general
					practice, most code should still be hidden from FFI functions to enhance modularity.
				</p>
				<p>
					This would also mean that installation of the game would require distinct distributions of
					the Engine library targetted to different platforms. In a full release, the Launcher should be
					able to download the suitable distribution onto user's computer; in beta stage, there might still
					not the complete Launcher come out yet, so most likely several binary packages (packed in archives)
					would be released.
				</p>
			</content>
		</section>
		<section title="Library and Distribution">
			<content>
				<embed src="./architecture.svg"/>
				<p>
					Since there is no longer need to write the code that uses various native libraries in Java/Kotlin,
					there is no actual need to use Lightweight Java Game Library (LWJGL). Also, given the maturity of
					Simple DirectMedia Layer (SDL) 3, while comparing the functionality supports between SDL 3 and
					Graphics Library Framework (GLFW), SDL 3 is actually leading its head for various functionalities,
					though not all supported features would be used. For some features like audio, different libraries
					for extensive features would be used, like OpenAL Soft.
				</p>
				<p>
					On the other hand, if parallel computing could be adapted, OpenCL might be suitable for a solution
					enhancing computing power for higher efficiency. Still, this requires hardware acceleration for
					great enhancement. For graphical computing, OpenGL would still be chosen, and
					Open Dynamics Engine (ODE) would be used for the physics supporting library. Even for encoding and
					decoding, using native libraries would enhance the efficiency effectively; this includes Opus and
					Free Lossless Audio Codec (FLAC), which would be used in the Engine instead of the Kotlin layer.
				</p>
				<p>
					For distribution, native library dependencies may be handled by having them dynamically linked,
					unlike Rust dependencies that are mostly statically linked. Also, keeping them dynamically linked
					could ensure modularity and size efficiency. On Linux and macOS, when those could be the ones that
					are system-wide installed or already installed on the system, they could be skipped by the Launcher
					and the system libraries could be included them in the library path. To load the native
					dependencies of the Engine, <code>System.loadLibrary</code> could be used, but could be
					troublesome, thus, leveraging the system library loader to include the paths may be better.
					In general, Windows searches libraries in the file's parent directory but on Linux and macOS,
					either <code>LD_LIBRARY_PATH</code>/<code>DYLD_LIBRARY_PATH</code> of the game's native library
					path has to be set as an environment variable (by <code>process::Command::env</code>) before
					launching or setting <code>RPATH</code> to the Engine library. The latter may be the most flexible.
					If there exist some existing libraries or widespread system libraries like <code>libopus</code>,
					those libraries could be ignored when downloading onto Linux or macOS clients, installing those
					globally via package manager if not installed and letting system's loader handle.
					The soname system on Linux and macOS is adopted for library versioning, such that follow a major
					version should ensure compatibility with future versions with the major version, but except that
					not all libraries may follow this rule; this is handled for system-installed libraries when
					required, so bundling them with the Engine without relying on system libraries would avoid this
					potential incompatibility when such libraries are not widely adapted.
					Common libraries like <code>libopus</code> and <code>libFLAC</code> both follow Semantic Versioning
					and Linux's SONAME-based versioning, so they may be used from system libraries.
					It is also important to check whether the required version is the same or older than the one
					installed on the system with the same major version and perform update via the system's
					package manager.
					This could also ensure common practice on using dynamic libraries on UNIX-like platforms and size
					efficiency of the Launcher's game native library directory, though not applicable on Windows.
				</p>
				<p>
					For some dependencies of the Engine, there may exist some native dependencies. One may either
					statically or dynamically link them to the Engine, but the latter might be more favorable to
					manage better for memory usage and efficiency, as well as the aforementioned modularity
					allowing system-installed libraries to be used. To distribute the native libraries, one may
					only either copy the builds built from source during the Engine build process or build separately
					from the Engine build. For the former method, it seems to be no other ways to locate the built
					binaries within the build script as build scripts seem to be isolated from other crates' builds;
					it is only possible to fork an existing <code>*-sys</code> crate or have a custom crate for
					bindings and native library builds, with code that copies the resultant binaries to the target
					directory near the Engine binary in the same directory.
					For the latter method, there must be a workflow to ensure that the source version of the library
					used by the binding crate is the same as the one separately built or obtained for distribution;
					as long as the versions are the same, there should be no gap of implementation between the binaries.
					Since the built binaries use soname, it is necessary to locate the binary with the filename matched
					exactly the same as the soname of the library when copying binaries to output by following symlinks,
					to ensure the library could be loaded by library loader.
				</p>
			</content>
		</section>
		<section title="Language Communication Layer">
			<content>
				<p>
					Since the Engine would eventually be compiled into native libraries, which are not directly
					compatible with JVM without an extra layer of transition, which is typical JNI.
					Despite the emergence of modern projects like Project Panama, UniFFI, and JNR-FFI, which offer
					alternative tools for bridging native code with JVM-managed code, JNI is still adopted
					to maintain the neatness of the overall project framework. It helps preserve the clarity of the
					project's overall framework while streamlining development workflows by relying on the
					traditional toolset. Detailed workflow and process are still subject to consideration. Moreover,
					further researches and investigation may have to be employed to consider whether the certain
					toolset is suitable for this project architecture.
				</p>
				<p>
					On the Kotlin layer, several classes wrapping the Engine's functionalities exist, stored in
					<code>terramodulus.engine.ferricia</code> package. Those classes load the same generated dynamic
					library built by the Engine project with specified function signatures. All these functions must
					be used internally, so they should be marked with <code>internal</code> visibility in their
					signatures. In the package of<code>terramodulus.engine</code>, several classes would be made to
					directly use the classes and functions in <code>terramodulus.engine.ferricia</code>.
					Please note that all the usages within such classes would be low level, meaning that its code style
					should not be subject to the high level code style guidelines. It is good to separate client-only
					and server-only classes into different modules so that they could be loaded with the built binary
					with crate feature selected. Moreover, it may eventually come to the situation that the Kotlin
					abstraction of the Engine itself could be made an isolated module named <code>internal</code> with
					public interface exposed to other modules, to hide the low level components directly accessing
					the Engine.
				</p>
				<p>
					To reduce JNI invoking overheads, the exposed functions should contain only essential code with
					using the least call sites of exposed functions as far as possible for a single scope in
					abstraction.
				</p>
			</content>
		</section>
		<section title="Debugging">
			<content>
				<p>
					Since logging in a library is challenging to control, logging in production builds should only
					occur in the Kotlin layer. Thus, the Engine may not have any logs in production builds. However,
					debugging logs may be printed in development builds, with toggles without affecting much on
					performance. Also, using flags could be managed better than commenting out logging code.
				</p>
				<p>
					It should be careful when managing what parts of the code should be put in the Kotlin layer and
					what other parts should be kept in the Engine. If there are important parts requiring logging
					status and information, they might be put into the Kotlin layer. Moreover, if status could be
					stored in objects and sent to Kotlin, the information may then be logged by the Kotlin layer,
					but it depends on whether it is suitable in the specific scenarios.
				</p>
			</content>
		</section>
		<section title="Resource Management">
			<content>
				<p>
					Most resources that are only used in the Engine, such as textures, rendering models and shaders,
					should be kept in the Engine without exposing too much interface to the Kotlin layer.
					It is possible that the controls in the Kotlin layer over these resources may become barely
					<i>handles</i> without more operations allowed. However, higher level management like registries
					is still managed in the Kotlin layer, at least with primary management operations like loading
					and closing. It is not recommended to permit third parties to have further controls over these
					<i>hidden</i> resources in the Engine via plugins or mods.
				</p>
				<p>
					For any resource, it is always recommended to free up resources when they are no longer used.
					Also, when possible, resources may still be freed up when unexpected failures or crashes have
					occurred. Moreover, if there still exists certain resources cannot be freed up when failures
					or crashes happen, modern operating systems may still be allowed to free them up in the
					system level.
				</p>
				<p>
					When there exist some encapsulated, hidden or opaque native objects in the Engine, that are
					supposed to be persisted out of the scope of single exported native function invocation,
					the specific data structures may be defined within the Engine code without having the abstraction
					form of the data objects defined in the Kotlin layer. The allocated objects should be
					converted into a form of pointer by initializing a <code>Box</code> and casting to a raw pointer
					as <code>long</code> via <code>Box::into_raw</code>; intermedia value read and write may be
					performed from a dereference with borrow to the raw pointer passed from the Kotlin layer;
					destruction of the objects should be invoked with <code>Box::from_raw</code>. All the object
					management is handled within the internal part of the Kotlin communication layer with
					the low level interface of the Engine.
				</p>
			</content>
		</section>
		<section title="Threading">
			<content>
				<p>
					Thread would mostly be managed in the Kotlin layer, but the Engine may also have its threading
					management especially for networking and parallel computing. However, it is possible that in
					the abstraction of networking, there would already be threading used in the Kotlin layer, without
					having to use threading in the Engine directly; this still requires clear planning and layout.
					For computational heavy tasks, if parallel computing is eligible, the Engine would allocate
					appropriate threads in its thread pool to enhance computing, without abstraction layer's
					interference.
				</p>
			</content>
		</section>
		<section title="See also">
			<content>
				<list>
					<li><a href="../efp003">EFP 3</a></li>
					<li><a href="../efp004">EFP 4</a></li>
				</list>
			</content>
		</section>
	</body>
</efp>
